\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amsbsy, amssymb}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage{multicol}
\usepackage{vwcol}
\usepackage{xcolor}
\usepackage{svg}
\usepackage{tabularx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{etoolbox}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{amsmath,amssymb}
\usepackage{pifont}


\newcommand{\curly}{\mathrel{\leadsto}}

\titleformat{\subsection}[hang]
  {\normalfont\bfseries}
  {}
  {0em}
  {}

\newcommand{\setupsizes}[1]{
    \usepackage[fontsize=#1]{fontsize}
    \usepackage{helvet}
    \renewcommand{\familydefault}{\sfdefault}
    \usepackage{titlesec}
    \titleformat*{\section}{\large\bfseries}
    \titleformat*{\subsection}{\normalsize\bfseries}
    \titlespacing*{\section}{0pt}{1em}{0.65em}
    \titlespacing*{\subsection}{0pt}{0.5em}{0.5em}
    \pagenumbering{gobble}
    \usepackage[a4paper,top=1cm,bottom=1cm,left=1cm,right=1cm]{geometry}
    \setlength{\parindent}{0em}
    \setlength{\parskip}{0.65em}
    \setlength{\intextsep}{1em}
    \setlength{\abovedisplayskip}{1em}
    \setlength{\belowdisplayskip}{1em}
    \setlength{\abovedisplayshortskip}{1em}
    \setlength{\belowdisplayshortskip}{1em}
}

\setcounter{tocdepth}{1}
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}

\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}

\usepackage{listings}
\lstset{
    inputencoding=utf8,
    extendedchars=\true,
    basicstyle=\ttfamily\small,
    mathescape,
    literate=%
        {á}{{\'a}}1
        {é}{{\'e}}1
        {í}{{\'i}}1
        {ó}{{\'o}}1
        {ú}{{\'u}}1
        {Á}{{\'A}}1
        {É}{{\'E}}1
        {Í}{{\'I}}1
        {Ó}{{\'O}}1
        {Ú}{{\'U}}1
        {ñ}{{\~n}}1
        {Ñ}{{\~N}}1
}

\usepackage{pifont}
\newcommand{\xmark}{\color{purple}\ding{54}}

\newcommand{\xor}{\oplus}
\newcommand{\nor}{\downarrow}
\newcommand{\opsub}[2]{\ensuremath{#1_{\mathrm{#2}}}}
\newcommand{\yLuego}{\opsub{\land}{\scriptscriptstyle{L}}}
\newcommand{\oLuego}{\opsub{\lor}{\scriptscriptstyle{L}}}
\newcommand{\implicaLuego}{\opsub{\implies}{\scriptscriptstyle{L}}}
\renewcommand{\implies}{\Rightarrow}

\usepackage{colortbl}
\newcolumntype{x}{>{\columncolor[HTML]{FFF2CC}}c}

\AtBeginEnvironment{algorithmic}{\small}

\captionsetup[algorithm]{labelformat=empty}

\newcommand{\Complexity}[1]{\textbf{Complejidad}: #1}
\newcommand{\Pre}[1]{\textbf{Pre} $\equiv$ \{#1\}}

\newcommand{\meta}[1]{\textcolor{gray}{#1}}

\setupsizes{11pt}

\begin{document}

\hfill
Matías Eliel Waisman 

\section*{Enunciado}
\section*{\normalsize{AED Primer Cuatrimestre 2024 / Práctica 8 - Ordenamiento / Ejercicio 5}}

Se tiene un arreglo de \(n\) números naturales que se quiere ordenar por frecuencia, y en caso de igual frecuencia,
por su valor. Por ejemplo, a partir del arreglo [1, 3, 1, 7, 2, 7, 1, 7, 3] se quiere obtener [1, 1, 1, 7, 7, 7, 3, 3, 2].
Describa un algoritmo que realice el ordenamiento descrito, utilizando las estructuras de datos intermedias que
considere necesarias. Calcule el orden de complejidad temporal del algoritmo propuesto

\section*{Contexto y conocimientos previos del alumno}
Este ejercicio se encuentra al principio de la guía de ordenamiento. Puede ser uno de los primeros ejercicios a dar en una clase practica luego de introducir los algoritmos de ordenamiento y me parece un buen ejercicio para mostrar: 
Como usar las estructuras de datos a la hora de resolver problemas (en particular de ordenamiento), la importancia de los algoritmos de ordenamiento estables y como podemos reducir un problema menos general en uno más general que si sabemos resolver (en particular uno de ordenamiento). 

Se asume que los alumnos: 
\begin{itemize}
    \item Saben determinar el orden de complejidad temporal del peor caso de un algoritmo.
    \item Estan familiarizados con las estructuras de datos presentadas en la guía de elección de estructuras y las complejidades de sus operaciones.
    \item Estan familiarizados con los algoritmos de ordenamiento, no como implementarlos de memoria sino como funcionan, sus invariantes y complejidades.
    \item \textbf{Nunca} resolvieron un ejercicio de ordenamiento en el que hace falta ordenar por más de un criterio y ejercicios de ordenamiento con tuplas.
\end{itemize}

\section*{Desarrollo del ejercicio}
\meta{Observación del enunciado:} En este problema no solamente hay que ordenar por cantidad de apariciones, de mayor a menor, si no que tambien en caso de que dos elementos tengan la misma cantidad de apariciones tiene que ser de menor a mayor. 

\subsection{Preguntas orientadoras para encaminar la resolución del ejercicio}
¿Se vuelve más fácil el problema de ordenar si en vez de tener la lista: [\textcolor{green}{1}, \textcolor{cyan}{3}, \textcolor{green}{1}, \textcolor{green}{7}, \textcolor{blue}{2}, \textcolor{green}{7}, \textcolor{green}{1}, \textcolor{green}{7}, \textcolor{cyan}{3}] tenemos la lista: 
[(1, \textcolor{green}{3}), (3, \textcolor{cyan}{2}),(7, \textcolor{green}{3}), (2, \textcolor{blue}{1})]? 
¿Que representa cada tupla respecto de los elementos de lista original?

Si ahora en vez de ordenar la lista original por los criterios del enunciado, la queremos ordenar primero por la segunda componente de las tuplas en orden descendente y en caso de empate por la segunda en orden ascendente, se vuelve un problema más fácil? ¿Cómo pódemos hacerlo?

\section*{Resolución}
Podemos separar el problema en varios subproblemas a resolver:
\begin{enumerate}
    \item Transformar la lista original en una lista de tuplas.
    \item Ordenar la lista de tuplas con los criterios que nos interesan.
    \item Reconstruir la solución.
\end{enumerate}
\subsubsection*{Paso 1: Transformar la lista original}
Una primera intuición para llegar a la lista de tuplas puede ser recorrer la lista original, pero: ¿Cómo hacemos para guardar la cantidad de apariciones de cada elemento?

Dentro de los ejercicios de Sorting es muy común tener que apoyarnos en estructuras de datos auxiliares además de la lista original para llegar a nuestro cometido. Por lo que podemos apoyarnos de un diccionario implementado sobre un AVL (DiccLog) para ir actualizando la cantidad de apariciones de los elementos. Y una vez que tenemos para cada elemento de la lista original su cantidad de apariciones con el iterador del diccionario podemos terminar de construir la lista de tuplas.

Entonces modularizemos este proceso en dos funciones: Una que a partir de la lista va a devolver un diccionario, y otra que a partir del diccionario va a devolver una lista de tuplas. 
\begin{algorithm}[H]
    \caption{
        \textbf{proc crearDiccionarioDeCantidades}(\textbf{in} arr: \textnormal{Array\textless{}nat\textgreater{}}) $\to$ \textbf{out} res:  \textnormal{DiccLog\textless{}nat, nat\textgreater{}}
    }
    \begin{algorithmic}[1]
        \State var res: \textnormal{DiccLog\textless{}nat, nat\textgreater{}} = new diccionarioVacío();  \Comment {$O(1)$}
        \State var i: int = 0;
        \While{i $<$ arr.longitud()} \Comment {$O(n)$}
            \State var actual: int = arr[i]; \Comment {$O(1)$}
            \If{res.está(actual)} \Comment {$O(Log(n))$}
                \State var previo: int = res.obtener(actual); \Comment {$O(Log(n))$}
                \State \hyperref[sec:explanation1]{previo = previo + 1; \textcolor{blue}{$*^{1}$}}
            \Else
                \State res.definir(actual, 1); \Comment {$O(Log(n))$}
            \EndIf 
            \State i = i + 1;
        \EndWhile
    \State return res;
    \end{algorithmic}
    \Complexity{$O(n) \times O(2Log(n)) = O(nLog(n)) \text{ con } n = arr.longitud()$ }
\end{algorithm}

\label{sec:explanation1}
\textcolor{blue}{$*^{1}$}Asumimos que hay aliasing, por lo que cuando pedimos el valor asociada a una clave en el diccionario, al modificar el valor no hace falta volver a modificar el par clave valor. (Agregar explicación de porque pasa)
\begin{algorithm}[H]
    \caption{
        \textbf{proc crearArrayDeTuplas}(\textbf{in} dict: \textnormal{DiccLog\textless{}nat, nat\textgreater{}}) $\to$ \textbf{out} res: \textnormal{Array\textless{}Tupla \textless{}nat, nat\textgreater{}\textgreater{}}
    }
    \begin{algorithmic}[1]
        \State var res: Array\textless{}Tupla \textless{} nat, nat \textgreater{}\textgreater{} = new Array(dict.tamaño()); \Comment {$O(n)$}
        \State \hyperref[sec:explanation2] {var it : IteradorBidireccional = dict.iterador(); \textcolor{cyan}{$*^{2}$}}  \Comment{$O(1)$}
        \State var i: int = 0;
        \While{i $<$ dict.tamaño()} \Comment{$O(n)$}
            \State res[i] = it; \Comment{$O(1)$}
            \State it.siguiente(); \Comment{$O(1)$}
            \State i = i + 1;
        \EndWhile
        \State return res;
    \end{algorithmic}
    \Complexity{$O(n) \text{ con } n = \text{dict.tamaño()}$}
\end{algorithm}
\label{sec:explanation1}

\textcolor{cyan}{$*^{2}$} Recordar que el iterador está representado como una tupla, cuyo primer elemento es la clave y el segundo el valor.

Agregar comentario complejidad recorrer el diccionario.

\subsubsection*{Paso 2: Ordenar el arreglo de tuplas}
Una vez que llegamos al array de tuplas y es momento de ordenarlo es crucial elegir bien por cual criterio vamos a ordenar primero y si los algoritmos de ordenamiento que vamos a usar son estables o no.


Como queremos que el criterio principal a ordenar sea por cantidad de apariciones de mayor a menor y en caso de empate en cantidad de apariciones va a ir primero el menor numero. La solución va a ser primero ordenar el primer elemento de la tupla de menor a mayor con cualquier algoritmo de ordenamiento y luego con un algoritmo de ordenamiento \textbf{estable}.

¿Porque es crucial que sea estable el segundo ordenamiento? Porque si no vamos a perder el orden del primer ordenamiento. Por ejemplo si primero ordenamos por la primera clave de menor a mayor y luego ordenamos la segunda de mayor a menor usando Heap Sort, que no es estable, lo que pasaría sería:

[(1, \textcolor{green}{3}), (3, \textcolor{cyan}{2}), (7, \textcolor{green}{3}), (2, \textcolor{blue}{1})] \textcolor{green}{$\curly$} [(1, \textcolor{green}{3}), (2, \textcolor{blue}{1}), (7, \textcolor{green}{3}), (3, \textcolor{cyan}{2})] \textcolor{red}{$\curly$} [(7, \textcolor{green}{3}), (1, \textcolor{green}{3}), (3, \textcolor{cyan}{2}), (2, \textcolor{blue}{1})] \textcolor{red}{$\curly$} [7,7,7,1,1,1,3,3,2] \textcolor{red}{\ding{55}}

En cambio con un algoritmo de ordenamiento estable: 

[(1, \textcolor{green}{3}), (3, \textcolor{cyan}{2}), (7, \textcolor{green}{3}), (2, \textcolor{blue}{1})] \textcolor{green}{$\curly$} [(1, \textcolor{green}{3}), (2, \textcolor{blue}{1}), (7, \textcolor{green}{3}), (3, \textcolor{cyan}{2})] \textcolor{green}{$\curly$} [(1, \textcolor{green}{3}), (7, \textcolor{green}{3}), (3, \textcolor{cyan}{2}), (2, \textcolor{blue}{1})] \textcolor{green}{$\curly$} [1,1,1,7,7,7,3,3,2] \textcolor{green}{\ding{51}}

\meta{¿Se podría ordenar primero por el primer criterio y luego por el segundo?}

Un contraejemplo de que este procedimiento no nos daría la solución correcta lo podemos ver siguiendo los resultados de los ordenamientos más el pasaje a array:

[(1, \textcolor{green}{3}), (3, \textcolor{cyan}{2}), (7, \textcolor{green}{3}), (2, \textcolor{blue}{1})] \textcolor{red}{$\curly$} [(1, \textcolor{green}{3}), (7, \textcolor{green}{3}), (3, \textcolor{cyan}{2}), (2, \textcolor{blue}{1})] \textcolor{red}{$\curly$} [(1, \textcolor{green}{3}), (2, \textcolor{blue}{1}), (3, \textcolor{cyan}{2}), (7, \textcolor{green}{3})] \textcolor{red}{$\curly$} [1,1,1,2,3,3,7,7,7] \textcolor{red}{\ding{55}}

\begin{algorithm}[H]
    \caption{
        \textbf{proc ordenarTuplas}(\textbf{in} arr: \textnormal{Array\textless{}Tupla\textless{}nat, nat\textgreater{}\textgreater{}}) $\to$ \textbf{out} arr: \textnormal{Array\textless{}Tupla\textless{}nat, nat\textgreater{}\textgreater{}}
    }
    \begin{algorithmic}[1]
        \State mergeSort(arr) \Comment{De menor a mayor por el primer componente. $O(nLog(n))$}
        \State mergeSort(arr) \Comment{De mayor a menor por el segundo componente. $O(nLog(n))$}
        \State return arr;
    \end{algorithmic}
    \Complexity{$O(nLog(n)) \text{ con } n = arr.longitud()$}
\end{algorithm}

\subsubsection*{Paso 3: Reconstruir la solución}
\begin{algorithm}[H]
    \caption{
        \textbf{proc reconstruirArray}(\textbf{in} arr:\textnormal{Array\textless{}Tupla\textless{}nat, nat\textgreater{}\textgreater{}}, int tamaño)$\to$ \textbf{out} res: \textnormal{Array\textless{}nat\textgreater{}}
    }
    \begin{algorithmic}[1]
        \State var res: Array\textless{}nat\textgreater{} = new Array(tamaño); \Comment{$O(n)$}
        \State var i: int = 0;
        \State var indiceActual = 0;
        \While{i $<$ arr.longitud}
            \State var j: int = 0;
            \While{j $<$ arr[i].second}
                \State res[indiceActual] = arr[i].first;
                \State indiceActual = indiceActual + 1;
                \State j = j + 1;
            \EndWhile{}
            \State i = i + 1;
        \EndWhile
        \State return res;
    \end{algorithmic}
    \Complexity{}
\end{algorithm}
\end{document}
