\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amsbsy, amssymb}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage{multicol}
\usepackage{vwcol}
\usepackage{xcolor}
\usepackage{svg}
\usepackage{tabularx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{etoolbox}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{titlesec}
\usepackage{hyperref}

\titleformat{\subsection}[hang]
  {\normalfont\bfseries}
  {}
  {0em}
  {}

\newcommand{\setupsizes}[1]{
    \usepackage[fontsize=#1]{fontsize}
    \usepackage{helvet}
    \renewcommand{\familydefault}{\sfdefault}
    \usepackage{titlesec}
    \titleformat*{\section}{\large\bfseries}
    \titleformat*{\subsection}{\normalsize\bfseries}
    \titlespacing*{\section}{0pt}{1em}{0.65em}
    \titlespacing*{\subsection}{0pt}{0.5em}{0.5em}
    \pagenumbering{gobble}
    \usepackage[a4paper,top=1cm,bottom=1cm,left=1cm,right=1cm]{geometry}
    \setlength{\parindent}{0em}
    \setlength{\parskip}{0.65em}
    \setlength{\intextsep}{1em}
    \setlength{\abovedisplayskip}{1em}
    \setlength{\belowdisplayskip}{1em}
    \setlength{\abovedisplayshortskip}{1em}
    \setlength{\belowdisplayshortskip}{1em}
}

\setcounter{tocdepth}{1}
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}

\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}

\usepackage{listings}
\lstset{
    inputencoding=utf8,
    extendedchars=\true,
    basicstyle=\ttfamily\small,
    mathescape,
    literate=%
        {á}{{\'a}}1
        {é}{{\'e}}1
        {í}{{\'i}}1
        {ó}{{\'o}}1
        {ú}{{\'u}}1
        {Á}{{\'A}}1
        {É}{{\'E}}1
        {Í}{{\'I}}1
        {Ó}{{\'O}}1
        {Ú}{{\'U}}1
        {ñ}{{\~n}}1
        {Ñ}{{\~N}}1
}

\usepackage{pifont}
\newcommand{\xmark}{\color{purple}\ding{54}}

\newcommand{\xor}{\oplus}
\newcommand{\nor}{\downarrow}
\newcommand{\opsub}[2]{\ensuremath{#1_{\mathrm{#2}}}}
\newcommand{\yLuego}{\opsub{\land}{\scriptscriptstyle{L}}}
\newcommand{\oLuego}{\opsub{\lor}{\scriptscriptstyle{L}}}
\newcommand{\implicaLuego}{\opsub{\implies}{\scriptscriptstyle{L}}}
\renewcommand{\implies}{\Rightarrow}

\usepackage{colortbl}
\newcolumntype{x}{>{\columncolor[HTML]{FFF2CC}}c}

\AtBeginEnvironment{algorithmic}{\small}

\captionsetup[algorithm]{labelformat=empty}

\newcommand{\Complexity}[1]{\textbf{Complejidad}: #1}
\newcommand{\Pre}[1]{\textbf{Pre} $\equiv$ \{#1\}}

\newcommand{\meta}[1]{\textcolor{gray}{#1}}

\setupsizes{11pt}

\begin{document}

\hfill
Matías Eliel Waisman 

\section*{Enunciado}
\section*{\normalsize{AED Primer Cuatrimestre 2024 / Práctica 8 - Ordenamiento / Ejercicio 5}}

Se tiene un arreglo de \(n\) números naturales que se quiere ordenar por frecuencia, y en caso de igual frecuencia,
por su valor. Por ejemplo, a partir del arreglo [1, 3, 1, 7, 2, 7, 1, 7, 3] se quiere obtener [1, 1, 1, 7, 7, 7, 3, 3, 2].
Describa un algoritmo que realice el ordenamiento descrito, utilizando las estructuras de datos intermedias que
considere necesarias. Calcule el orden de complejidad temporal del algoritmo propuesto

\section*{Contexto y conocimientos previos del alumno}
Este ejercicio se encuentra al principio de la guía de ordenamiento. Puede ser uno de los primeros ejercicios a dar en una clase practica luego de introducir los algoritmos de ordenamiento y me parece un buen ejercicio para mostrar: 
Como usar las estructuras de datos a la hora de resolver problemas (en particular de ordenamiento), la importancia de los algoritmos de ordenamiento estables y como podemos reducir un problema menos general en uno más general que si sabemos resolver (en particular uno de ordenamiento). 

Se asume que los alumnos: 
\begin{itemize}
    \item Saben determinar el orden de complejidad temporal del peor caso de un algoritmo.
    \item Estan familiarizados con las estructuras de datos presentadas en la guía de elección de estructuras y las complejidades de sus operaciones.
    \item Estan familiarizados con los algoritmos de ordenamiento, no como implementarlos de memoria sino como funcionan, sus invariantes y complejidades.
    \item \textbf{Nunca} resolvieron un ejercicio de ordenamiento en el que hace falta ordenar por más de un criterio y ejercicios de ordenamiento con tuplas.
\end{itemize}

\section*{Desarrollo del ejercicio}
\meta{Observación del enunciado:} En este problema no solamente hay que ordenar por cantidad de apariciones, de mayor a menor, si no que tambien en caso de que dos elementos tengan la misma cantidad de apariciones tiene que ser de menor a mayor. 

\subsection{Preguntas orientadoras para encaminar la resolución del ejercicio}
¿Se vuelve más fácil el problema de ordenar si en vez de tener la lista: [\textcolor{green}{1}, \textcolor{cyan}{3}, \textcolor{green}{1}, \textcolor{green}{7}, \textcolor{blue}{2}, \textcolor{green}{7}, \textcolor{green}{1}, \textcolor{green}{7}, \textcolor{cyan}{3}] tenemos la lista: 
[(1, \textcolor{green}{3}), (3, \textcolor{cyan}{2}),(7, \textcolor{green}{3}), (2, \textcolor{blue}{1})]? 
¿Que representa cada tupla respecto de los elementos de lista original?

Si ahora en vez de ordenar la lista original por los criterios del enunciado, la queremos ordenar primero por la segunda componente de las tuplas en orden descendente y en caso de empate por la segunda en orden ascendente, se vuelve un problema más fácil? ¿Cómo pódemos hacerlo?

\section*{Resolución}
Podemos separar el problema en varios subproblemas a resolver:
\begin{enumerate}
    \item Transformar la lista original en una lista de tuplas.
    \item Ordenar la lista de tuplas con los criterios que nos interesan.
    \item Reconstruir la solución.
\end{enumerate}
\subsubsection*{Paso 1: Transformar la lista original}
Una primera intuición para llegar a la lista de tuplas puede ser recorrer la lista original, pero: ¿Cómo hacemos para guardar la cantidad de apariciones de cada elemento?

Dentro de los ejercicios de Sorting es muy común tener que apoyarnos en estructuras de datos auxiliares además de la lista original para llegar a nuestro cometido. Por lo que podemos apoyarnos de un diccionario implementado sobre un AVL (DiccLog) para ir actualizando la cantidad de apariciones de los elementos. Y una vez que tenemos para cada elemento de la lista original su cantidad de apariciones con el iterador del diccionario podemos terminar de construir la lista de tuplas.

Entonces modularizemos este proceso en dos funciones: Una que a partir de la lista va a devolver un diccionario, y otra que a partir del diccionario va a devolver una lista de tuplas. 
\begin{algorithm}[H]
    \caption{
        \textbf{proc crearDiccionarioDeCantidades}(\textbf{in} l: \textnormal{Vector\textless{}nat\textgreater{}}): \textnormal{DiccLog\textless{}nat, nat\textgreater{}}
    }
    \begin{algorithmic}[1]
        \State var res: \textnormal{DiccLog\textless{}nat, nat\textgreater{}} = new diccionarioVacío();  \Comment {$O(1)$}
        \For{$i = 0$ \textbf{to} $l.longitud()$} \Comment {$O(n)$}
            \State var actual: int = l.obtener(i); \Comment {$O(1)$}
            \If{$res.\text{está}(actual)$} \Comment {$O(Log(n))$}
                \State var previo: int = res.obtener(actual); \Comment {$O(Log(n))$}
                \State \hyperref[sec:explanation1]{previo = previo + 1; \textcolor{blue}{$*^{1}$}}
            \Else
                \State res.definir(actual, 1); \Comment {$O(Log(n))$}
            \EndIf 
        \EndFor
    \State return res;
    \end{algorithmic}
    \Complexity{$O(n) \times O(2Log(n)) = O(nLog(n))$}
\end{algorithm}

\label{sec:explanation1}
\textcolor{blue}{$*^{1}$}Asumimos que hay aliasing, por lo que cuando pedimos el valor asociada a una clave en el diccionario, al modificar el valor no hace falta volver a modificar el par clave valor. (Agregar explicación de porque pasa)
\begin{algorithm}[H]
    \caption{
        \textbf{proc crearListaDeTuplas}(\textbf{in} dict: \textnormal{DiccLog\textless{}nat, nat\textgreater{}}): \textnormal{ListaEnlazada\textless{}Tupla \textless{} nat, nat \textgreater{}\textgreater{}}
    }
    \begin{algorithmic}[1]
        \State var res : ListaEnlazada\textless{}Tupla \textless{} nat, nat \textgreater{}\textgreater{} = vectorVacío(); \Comment {$O(1)$}
        \State \hyperref[sec:explanation2] {var it : IteradorBidireccional = dict.iterador(); \textcolor{cyan}{$*^{2}$}}  \Comment{$O(1)$}
        \While{it.haySiguiente()} \Comment{$O(n)$} 
            \State res.agregarAtras(it); \Comment{$O(1)$}
            \State it.siguiente();\Comment{$O(1)$}
        \EndWhile
        \State return res;
    \end{algorithmic}
    \Complexity{$O(n)$}
\end{algorithm}
\label{sec:explanation1}

\textcolor{cyan}{$*^{2}$} Recordar que el iterador está representado como una tupla, cuyo primer elemento es la clave y el segundo el valor.

Agregar comentario complejidad recorrer el diccionario.

\subsubsection*{Paso 2: Ordenar la lista de tuplas}
\subsubsection*{Paso 3: Reconstruir la solución}

\end{document}
